{"task_id": "HumanEval/163", "entry_point": "generate_integers", "strategies": ["cot", "self_planning"], "prompts": {"cot": "\ndef generate_integers(a, b):\n    \"\"\"\n    Given two positive integers a and b, return the even digits between a\n    and b, in ascending order.\n\n    For example:\n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10, 14) => []\n    \"\"\"\n\n\nFirst, reason step-by-step privately about the algorithm and tricky cases.\nThen, output ONLY valid Python code that implements `generate_integers` — no comments, no prints, no tests.", "self_planning": "\ndef generate_integers(a, b):\n    \"\"\"\n    Given two positive integers a and b, return the even digits between a\n    and b, in ascending order.\n\n    For example:\n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10, 14) => []\n    \"\"\"\n\n\nCreate a short implementation plan (inputs, outputs, edge cases, complexity).\nThen implement `generate_integers` exactly once following the plan.\nOutput ONLY the final Python code."}, "paths": {"cot": "/content/drive/MyDrive/CS520/selected_with_prompts_seed42/HumanEval__163/prompts/cot.txt", "self_planning": "/content/drive/MyDrive/CS520/selected_with_prompts_seed42/HumanEval__163/prompts/self_planning.txt"}}
{"task_id": "HumanEval/28", "entry_point": "concatenate", "strategies": ["cot", "self_planning"], "prompts": {"cot": "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\"\n\n\nFirst, reason step-by-step privately about the algorithm and tricky cases.\nThen, output ONLY valid Python code that implements `concatenate` — no comments, no prints, no tests.", "self_planning": "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\"\n\n\nCreate a short implementation plan (inputs, outputs, edge cases, complexity).\nThen implement `concatenate` exactly once following the plan.\nOutput ONLY the final Python code."}, "paths": {"cot": "/content/drive/MyDrive/CS520/selected_with_prompts_seed42/HumanEval__28/prompts/cot.txt", "self_planning": "/content/drive/MyDrive/CS520/selected_with_prompts_seed42/HumanEval__28/prompts/self_planning.txt"}}
{"task_id": "HumanEval/6", "entry_point": "parse_nested_parens", "strategies": ["cot", "self_planning"], "prompts": {"cot": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n\nFirst, reason step-by-step privately about the algorithm and tricky cases.\nThen, output ONLY valid Python code that implements `parse_nested_parens` — no comments, no prints, no tests.", "self_planning": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n\nCreate a short implementation plan (inputs, outputs, edge cases, complexity).\nThen implement `parse_nested_parens` exactly once following the plan.\nOutput ONLY the final Python code."}, "paths": {"cot": "/content/drive/MyDrive/CS520/selected_with_prompts_seed42/HumanEval__6/prompts/cot.txt", "self_planning": "/content/drive/MyDrive/CS520/selected_with_prompts_seed42/HumanEval__6/prompts/self_planning.txt"}}
{"task_id": "HumanEval/70", "entry_point": "strange_sort_list", "strategies": ["cot", "self_planning"], "prompts": {"cot": "\ndef strange_sort_list(lst):\n    '''\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n\n\nFirst, reason step-by-step privately about the algorithm and tricky cases.\nThen, output ONLY valid Python code that implements `strange_sort_list` — no comments, no prints, no tests.", "self_planning": "\ndef strange_sort_list(lst):\n    '''\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n\n\nCreate a short implementation plan (inputs, outputs, edge cases, complexity).\nThen implement `strange_sort_list` exactly once following the plan.\nOutput ONLY the final Python code."}, "paths": {"cot": "/content/drive/MyDrive/CS520/selected_with_prompts_seed42/HumanEval__70/prompts/cot.txt", "self_planning": "/content/drive/MyDrive/CS520/selected_with_prompts_seed42/HumanEval__70/prompts/self_planning.txt"}}
{"task_id": "HumanEval/62", "entry_point": "derivative", "strategies": ["cot", "self_planning"], "prompts": {"cot": "\n\ndef derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n\n\nFirst, reason step-by-step privately about the algorithm and tricky cases.\nThen, output ONLY valid Python code that implements `derivative` — no comments, no prints, no tests.", "self_planning": "\n\ndef derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n\n\nCreate a short implementation plan (inputs, outputs, edge cases, complexity).\nThen implement `derivative` exactly once following the plan.\nOutput ONLY the final Python code."}, "paths": {"cot": "/content/drive/MyDrive/CS520/selected_with_prompts_seed42/HumanEval__62/prompts/cot.txt", "self_planning": "/content/drive/MyDrive/CS520/selected_with_prompts_seed42/HumanEval__62/prompts/self_planning.txt"}}
{"task_id": "HumanEval/57", "entry_point": "monotonic", "strategies": ["cot", "self_planning"], "prompts": {"cot": "\n\ndef monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\"\n\n\nFirst, reason step-by-step privately about the algorithm and tricky cases.\nThen, output ONLY valid Python code that implements `monotonic` — no comments, no prints, no tests.", "self_planning": "\n\ndef monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\"\n\n\nCreate a short implementation plan (inputs, outputs, edge cases, complexity).\nThen implement `monotonic` exactly once following the plan.\nOutput ONLY the final Python code."}, "paths": {"cot": "/content/drive/MyDrive/CS520/selected_with_prompts_seed42/HumanEval__57/prompts/cot.txt", "self_planning": "/content/drive/MyDrive/CS520/selected_with_prompts_seed42/HumanEval__57/prompts/self_planning.txt"}}
{"task_id": "HumanEval/35", "entry_point": "max_element", "strategies": ["cot", "self_planning"], "prompts": {"cot": "\n\ndef max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n\n\nFirst, reason step-by-step privately about the algorithm and tricky cases.\nThen, output ONLY valid Python code that implements `max_element` — no comments, no prints, no tests.", "self_planning": "\n\ndef max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n\n\nCreate a short implementation plan (inputs, outputs, edge cases, complexity).\nThen implement `max_element` exactly once following the plan.\nOutput ONLY the final Python code."}, "paths": {"cot": "/content/drive/MyDrive/CS520/selected_with_prompts_seed42/HumanEval__35/prompts/cot.txt", "self_planning": "/content/drive/MyDrive/CS520/selected_with_prompts_seed42/HumanEval__35/prompts/self_planning.txt"}}
{"task_id": "HumanEval/26", "entry_point": "remove_duplicates", "strategies": ["cot", "self_planning"], "prompts": {"cot": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n\n\nFirst, reason step-by-step privately about the algorithm and tricky cases.\nThen, output ONLY valid Python code that implements `remove_duplicates` — no comments, no prints, no tests.", "self_planning": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n\n\nCreate a short implementation plan (inputs, outputs, edge cases, complexity).\nThen implement `remove_duplicates` exactly once following the plan.\nOutput ONLY the final Python code."}, "paths": {"cot": "/content/drive/MyDrive/CS520/selected_with_prompts_seed42/HumanEval__26/prompts/cot.txt", "self_planning": "/content/drive/MyDrive/CS520/selected_with_prompts_seed42/HumanEval__26/prompts/self_planning.txt"}}
{"task_id": "HumanEval/139", "entry_point": "special_factorial", "strategies": ["cot", "self_planning"], "prompts": {"cot": "\ndef special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n\n\nFirst, reason step-by-step privately about the algorithm and tricky cases.\nThen, output ONLY valid Python code that implements `special_factorial` — no comments, no prints, no tests.", "self_planning": "\ndef special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n\n\nCreate a short implementation plan (inputs, outputs, edge cases, complexity).\nThen implement `special_factorial` exactly once following the plan.\nOutput ONLY the final Python code."}, "paths": {"cot": "/content/drive/MyDrive/CS520/selected_with_prompts_seed42/HumanEval__139/prompts/cot.txt", "self_planning": "/content/drive/MyDrive/CS520/selected_with_prompts_seed42/HumanEval__139/prompts/self_planning.txt"}}
{"task_id": "HumanEval/22", "entry_point": "filter_integers", "strategies": ["cot", "self_planning"], "prompts": {"cot": "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"\n\n\nFirst, reason step-by-step privately about the algorithm and tricky cases.\nThen, output ONLY valid Python code that implements `filter_integers` — no comments, no prints, no tests.", "self_planning": "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"\n\n\nCreate a short implementation plan (inputs, outputs, edge cases, complexity).\nThen implement `filter_integers` exactly once following the plan.\nOutput ONLY the final Python code."}, "paths": {"cot": "/content/drive/MyDrive/CS520/selected_with_prompts_seed42/HumanEval__22/prompts/cot.txt", "self_planning": "/content/drive/MyDrive/CS520/selected_with_prompts_seed42/HumanEval__22/prompts/self_planning.txt"}}
